## fp-lang-for-llm
Now research then hopefully implementation of LLM friendly lang that compiles to fp lang

## Research material:
https://news.ycombinator.com/item?id=39619053#:~:text=IMHO%2C%20in%20the%20future%20programming,to%20generate%20provably%20correct%20code
https://arxiv.org/abs/2505.13453


## Main guidelines(proposal):
- language to be very simple - so LLM can learn it in few shots
- declarative? 
- should compile to purely fp lang
- there should be cleaning pipeline - that corrects any misspels or small syntax mistakes of LLM
- do not use similar keywords to "limit halucination". Do not use `==` and `=`, do not use similar symbols.
- machine/llm first - optimized for LLM not for human reading
- avoid optional elements or multiple ways to express the same idea


## Other ideas:
- ask stronger LLM - (GPT Pro?) for proposals


## CI/CD:
- tries to compile and run code "code"
    - if fails takes "code" generated by AI, cleans it if needed with another LLM
- another LLM to generate specification for input data -> runs program (I guess property based testing) with generated data of given specification

## Workflow

1 — Lock the surface syntax (once, not at run time)
Write a complete grammar (EBNF) and freeze it in version control.
Anything that isn’t in the grammar is illegal; no “fuzzy” acceptance for creative spacing, emojis, or half-invented keywords.
Document a bijective mapping from every DSL construct to a Haskell construct (function, type, class, etc.).
If you can’t explain the mapping in two sentences, the construct is too vague—delete or refine it.

2 - Front-end: parse + static checks
Stage	        Haskell library that actually works
Lex / parse	    megaparsec or tree-sitter
Typed AST	    Normal ADTs or safer GADTs
Name / scope	unbound-generics or your own symbol table
Type check	    Simple: your own algorithm; Refined: reuse GHC’s TcRn through the ghc API

3 — Desugar & lower to an internal Core
Your Core IR should already look 80–90 % like Haskell: λ-expressions, algebraic data types, case, let, literals.

4 - Emit real Haskell **(transpilation, not interpretation)**
Convert Core → ghc-lib-parser AST or haskell-src-exts
(avoid string-concatenation; it breaks on operator precedence and layout).
Pretty-print with prettyprinter.
Enforce -Wall -Werror layout so any unwanted whitespace triggers a compile error.

5 - Compile with GHC

High level:
- Freeze a grammar.
- Parse → typed AST → desugar → Haskell AST.
- Pretty-print, compile with -Werror, kill on any error.
- Optionally layer QuickCheck, LiquidHaskell, or Core-lint for extra proof.
